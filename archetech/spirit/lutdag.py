""" The module generates a DAG from a blif or verilog file, with each node
    represnting LUTs. ABC [https://people.eecs.berkeley.edu/~alanmi/abc/]
    is used for partioning the input into LUTs. """
import copy
import igraph
import logging
import os
import re
import sys

from .solution import Solution
from subprocess import PIPE, run


class LUT:
    """ A compact class to represent a logic function in SOP format """

    def __init__(self):
        self.name = None
        self.inputs = list()  # [v1 v2 v3...vn]
        self.output = None
        self.logic = list()  # [[v1v2v3...vn], [],...]
        self.__isConstant = False

    def getDim(self):
        return len(self.logic), len(self.inputs)

    def isConstant(self):
        return self.__isConstant

    def setConstant(self, cons):
        self.__isConstant = cons


class LutGraph:
    """ A class to generate a LUT graph from a blif or verilog file
        using ABC """

    def __init__(
        self, benchdir, benchfile, debug=False, logfile=None):
        self.__debug = debug
        self.__benchdir = benchdir
        self.__basename = benchfile[benchfile.rfind("/") + 1:]
        self.__benchname = benchfile
        
        self.__log = Solution()
        
        if logfile is not None:
            self.__logfile = logfile
        else:
            self.__logfile = benchdir + self.__basename + "_log.json"

    def genLutGraph(self, k):
        """ Partitions the benchmark into k-input LUTs using ABC """

        # generate the paritioned verilog file
        outf = self.__benchdir + "k" + str(k) + self.__basename
        if ".v" in self.__basename:
            readType = "read_verilog"
        elif ".blif" in self.__basename:
            readType = "read_blif"
        else:
            print("Invalid file type {}".format(self.__basename))
            return None

        abcinp = (
            readType
            + " "
            + self.__benchname
            + "\nstrash\n"
            + "if -K "
            + str(k)
            + "\n"
            + "write_verilog "
            + outf
            + "\nquit\n"
        )
        with open(self.__benchdir + "abcin", "w") as f:
            f.write(abcinp)
        command = ["abc", "-f", self.__benchdir + "abcin"]
        result = run(
            command, stdout=PIPE, stderr=PIPE, universal_newlines=True
        )

        logging.debug(result.returncode, result.stdout, result.stderr)
        if result.stderr != "":
            print(
                "Error: "
                + self.__basename
                + " could not be processed by ABC\n"
            )
            print("ABC output\n--------------------")
            print(result.stderr)
            return None
        else:
            print("Completed partitioning benchmark " + self.__benchname)
            # print(result.stdout)

        # get the LUT graph
        inputs, outputs, wires, assigns = self.readLUTVerilog(outf)

        # parse individual LUTs
        totalNodes = len(inputs) + len(outputs) + len(wires)
        lutGraph = igraph.Graph(directed=True)
        lutGraph.add_vertices(totalNodes)
        lutGraph.vs["name"] = inputs + outputs + wires
        # lutGraph.vs['lut'] = False
        lutGraph["inputs"] = inputs
        lutGraph["outputs"] = outputs

        for assignment in assigns:
            w, lut = self.getLUTFunc(assignment)
            if w is None:
                return None
            if self.__debug:
                print("lut:%s inputs:%s" % (w, lut.inputs))
            dest = lutGraph.vs.select(name=w)[0]
            dest["lut"] = lut
            if lut.isConstant() is False:
                for i in lut.inputs:
                    source = lutGraph.vs.select(name=i)[0]
                    # print('edge  %d->%d' %(source.index,dest.index))
                    lutGraph.add_edge(source.index, dest.index)
                    # print('node %d | predecessors: %s' % 
                    # \(dest.index, lutGraph.predecessors(dest.index)))
            else:
                print("omitted constant lut:{}".format(w))

        newGraph = igraph.Graph(directed=True)
        newGraph.add_vertices(totalNodes)
        newGraph.vs["name"] = copy.deepcopy(lutGraph.vs["name"])
        for e in lutGraph.es:
            newGraph.add_edge(e.source, e.target)
        newGraph.write_gml(
            self.__benchdir + "k" + str(k) + self.__basename + "_lg.gml",
            "SAC Technology Mapper",
        )  # does not work with lut objects
        return lutGraph

    def readLUTVerilog(self, filename):
        """ Read verilog which is output of if -k generated by ABC """

        f = open(filename)
        filedata = f.read()
        f.close()
        # Replace the target string
        filedata = filedata.replace("new_", "old_")
        # print(filedata)
        # Write the file out again
        with open(filename, "w") as file:
            file.write(filedata)

        bmfId = open(filename)
        data = bmfId.read()
        bmfId.close()

        InputList = (
            re.search("input (.*?);", data, re.DOTALL)
            .groups(0)[0]
            .replace(" ", "")
            .replace("\n", "")
            .split(",")
        )
        OutputList = (
            re.search("output (.*?);", data, re.DOTALL)
            .groups(0)[0]
            .replace(" ", "")
            .replace("\n", "")
            .split(",")
        )
        WireString = re.search("wire (.*?);", data, re.DOTALL)
        if WireString is not None:
            WireList = (
                WireString.groups(0)[0]
                .replace(" ", "")
                .replace("\n", "")
                .split(",")
            )
        else:
            WireList = []
        AssignList = re.findall("assign (.*?);", data, re.DOTALL)

        print(
            "File stats [%s] : %d inputs, %d outputs,\
         %d wires, %d assign "
            % (
                filename,
                len(InputList),
                len(OutputList),
                len(WireList),
                len(AssignList),
            )
        )

        self.__log.addParam("inputs", len(InputList))
        self.__log.addParam("outputs", len(OutputList))
        self.__log.addParam("wires", len(WireList))
        self.__log.addParam("assigns", len(AssignList))

        return InputList, OutputList, WireList, AssignList

    def __writeLUTFile(self, assignment, fname, assignLogic=None):
        """ Writes a temporary Verilog file with LUT assign statment
            `assignLogic` is used to write either the original statement
            or constant (1/0) """
        # get wire name
        output = assignment[: assignment.rfind("=")].strip()
        logic = assignment[assignment.rfind("=") + 1 :]
        inputs = re.findall("[a-zA-Z0-9\_\\\<\>]+", logic)
        inputs = list(set(inputs))
        if self.__debug:
            print(output, "|", inputs, assignment)

        file = open(fname, "w")
        file.write("module temp ( ")
        for inp in inputs:
            file.write(inp + " , ")
        file.write(output)
        file.write(" );\n")
        file.write("\tinput ")
        for i in range(len(inputs)):
            if i < len(inputs) - 1:
                file.write(inputs[i] + " , ")
            else:
                file.write(inputs[i] + " ;\n")
        file.write("\toutput " + output + " ;\n")
        if assignLogic is None:
            file.write("assign " + assignment + " ;\n")
        else:
            file.write("assign " + output + " = " + assignLogic + ";\n")
        file.write("endmodule\n")
        file.close()

    def getLUTFunc(self, assignment):
        """ Get the SOP representation of the LUT using ABC """
        
        tempfiles = [self.__benchdir + "lut.v"]
        self.__writeLUTFile(assignment, self.__benchdir + "lut.v")

        # get wire name
        output = assignment[: assignment.rfind("=")].strip()

        logic = assignment[assignment.rfind("=") + 1 :]
        inputs = re.findall("[a-zA-Z0-9\_\\\<\>]+", logic)
        inputs = list(set(inputs))

        # invoke ABC to generate SOP
        plaout = ""
        for ch in output:
            if ch == "_" or ch.isdigit() or ch.isalpha():
                plaout = plaout + ch
        abcinp = (
            "read_verilog "
            + self.__benchdir
            + "lut.v"
            + "\nstrash\ncollapse\n"
            + "write_pla "
            + self.__benchdir
            + "lutsop"
            + plaout
            + ".pla \n"
            + "\nquit\n"
        )
        tempfiles.append(self.__benchdir + "abcin")
        with open(self.__benchdir + "abcin", "w") as f:
            f.write(abcinp)
        command = ["abc", "-f", self.__benchdir + "abcin"]
        result = run(
            command, stdout=PIPE, stderr=PIPE, universal_newlines=True
        )

        # generate LUT object
        # print(result.returncode)
        isConstant = False

        if result.returncode != 0:
            # TODO: check if assignment is a contradiction
            print(assignment)
            tempfiles.append(self.__benchdir + "assign0.v")
            self.__writeLUTFile(assignment, self.__benchdir + "assign0.v", "0")

            tempfiles.append(self.__benchdir + "abcin")
            abcinp = (
                "cec "
                + self.__benchdir
                + "assign0.v"
                + " "
                + self.__benchdir
                + "lut.v  \n"
                + "quit\n"
            )
            with open(self.__benchdir + "abcin", "w") as f:
                f.write(abcinp)
            command = ["abc", "-f", self.__benchdir + "abcin"]
            result = run(
                command, stdout=PIPE, stderr=PIPE, universal_newlines=True
            )

            if result.returncode != 0:
                self.__log.addParam("error", "ABC output:" + output)
                self.writeJsonSolution()
                return None, None

            else:
                print(result.stdout, "are equivalent" in result.stdout)

                if "are equivalent" in result.stdout:
                    print("do something 0")
                    isConstant = "zero"
                    # sys.exit(1)
                else:
                    tempfiles.append(self.__benchdir + "assign0.v")
                    self.__writeLUTFile(
                        assignment, self.__benchdir + "assign0.v", "1"
                    )

                    tempfiles.append(self.__benchdir + "abcin")
                    abcinp = (
                        "cec "
                        + self.__benchdir
                        + "assign0.v"
                        + " "
                        + self.__benchdir
                        + "lut.v  \n"
                        + "quit\n"
                    )
                    with open(self.__benchdir + "abcin", "w") as f:
                        f.write(abcinp)
                    command = ["abc", "-f", self.__benchdir + "abcin"]
                    result = run(
                        command,
                        stdout=PIPE,
                        stderr=PIPE,
                        universal_newlines=True,
                    )

                    if result.returncode != 0:
                        self.__log.addParam("error", "ABC output:" + output)
                        self.__log.writeJsonSolution(self.__logfile)
                        return None, None
                    else:
                        print(result.stdout, "are equivalent" in result.stdout)
                        isConstant = "one"
                        print("do something 1")
                        # sys.exit(1)

        if isConstant:
            print("{} is constant:{}".format(output, isConstant))

        """ PLA file format example:
        # Benchmark "temp" written by ABC on Mon Sep  2 14:03:38 2019
        .i 3
        .o 1
        .ilb Cin B A
        .ob S
        .p 4
        001 1
        010 1
        100 1
        111 1
        .e
        """
        lutObj = LUT()
        if isConstant is False:
            # tempfiles.append(self.__benchdir+'lutsop'+output+'.pla')
            # check if parsing failed for some reason
            # TODO : need a better checking mechanism possibly
            if not os.path.isfile(
                self.__benchdir + "lutsop" + plaout + ".pla"
            ):
                with open(self.__benchdir + "failedParseBench.txt", "a") as f:
                    f.write(self.__benchname + "\n")
                print("Parsing failed for benchmark")
                self.__log.addParam("error", "Parsing failed for benchmark")
                self.__log.writeJsonSolution(self.__logfile)
                return None, None

            with open(self.__benchdir + "lutsop" + plaout + ".pla") as f:
                lines = f.readlines()
                for i in range(len(lines)):
                    if lines[i].find(".ilb ") >= 0:
                        inputList = lines[i]
                        inputList = (
                            inputList[inputList.find(".ilb ") + 4 :]
                            .strip()
                            .split()
                        )
                        break
                terms = None
                for j in range(i, len(lines)):
                    if lines[j].find(".p ") >= 0:
                        terms = lines[j]
                        terms = int(terms[terms.find(" ") : terms.rfind("\n")])
                        if self.__debug:
                            print(terms)
                        break
                sop = lines[j + 1 : j + terms + 1]
                for i in range(len(sop)):
                    t = sop[i]
                    t = t[: t.rfind(" ")].strip()
                    sop[i] = t
                if self.__debug:
                    print(inputList, sop)

            lutObj.inputs = inputs
            lutObj.output = output
            lutObj.logic = sop
            tempfiles.append(self.__benchdir + "lutsop" + plaout + ".pla")
        else:
            lutObj.setConstant(isConstant)

        # clean temporary files
        # for tempf in tempfiles:

        #     if os.path.exists(tempf):
        #         os.remove(tempf)
        
        
        return output, lutObj
